# -*- coding: utf-8 -*-
"""Smartphone pricing classification.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ZE1YiyXXjlEwTtzX0sJCc3oxtQNTlklk
"""

from IPython.display import Javascript
def resize_colab_cell():
  display(Javascript('google.colab.output.setIframeHeight(0, true, {maxHeight: 5000})'))
get_ipython().events.register('pre_run_cell', resize_colab_cell)

from google.colab import drive
drive.mount('/content/drive')

#importing necessary libraries
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.svm import SVC
from sklearn.preprocessing import LabelEncoder
from sklearn.feature_selection import SelectKBest, chi2
from sklearn.preprocessing import MinMaxScaler
from sklearn.metrics import accuracy_score, precision_score, recall_score, confusion_matrix, classification_report
from sklearn.model_selection import train_test_split
# from sklearn.datasets import load_iris
from sklearn.model_selection import train_test_split
from sklearn.tree import DecisionTreeClassifier
from sklearn.metrics import accuracy_score, classification_report
import warnings
warnings.filterwarnings("ignore")

"""## Dataset Reading"""

mobile = pd.read_csv('/content/drive/MyDrive/CSE422/422_LABPROJECT/Dataset_422Project.csv')
mobile.head(20)

"""### ***DATASET DESCRIPTION***"""

mobile.shape

mobile.columns.tolist()

mobile.dtypes

mobile.nunique()

mobile.isnull().sum()

"""### ***DATA PREPROCESSING***"""

mobile = mobile.drop(['AI', 'Thermal Imaging Camera'], axis = 1)
mobile.shape

label_encoder = LabelEncoder()
mobile['network'] = label_encoder.fit_transform(mobile['network'])

from sklearn.impute import SimpleImputer

impute = SimpleImputer(missing_values=np.nan, strategy='mean')

impute.fit(mobile[['talk_time']])

mobile['talk_time'] = impute.transform(mobile[['talk_time']])

mobile.head(20)

"""### ***DATA VISUALIZATION***"""

class_distribution = mobile['Price_range'].value_counts()


plt.figure(figsize=(8, 6))
class_distribution.plot(kind='bar', color='skyblue')
plt.title("Class Distribution of Price_range")
plt.xlabel("Price_range")
plt.ylabel("Number of Instances")
plt.xticks(rotation=0)
plt.show()

corr=abs(mobile.corr())
plt.figure(figsize=(15,15))
sns.heatmap(corr, annot=True, vmin=0, vmax=1, cmap='Blues', fmt='.2f')
plt.show()

Columns =list(mobile[['fc','network',
                      'm_dep','n_cores','pc','sc_h','sc_w',
                      'talk_time']])

plt.figure(figsize=(15,20))

for i in range(len(Columns)):

    plt.subplot(5,3,i+1)
    plt.title(Columns[i])
    sns.countplot(x=mobile[Columns[i]])


plt.tight_layout()
plt.show()

sns.distplot(mobile['battery_power'])

sns.distplot(mobile['ram'])

plt.figure(figsize=(10,5))
plt.title('Distribution Battery Power in Each Price range')
sns.boxplot(x=mobile['Price_range'],y=mobile['battery_power'])
plt.xlabel('Price Range')
plt.ylabel('Battery Power')
plt.show()

ram = mobile.groupby("Price_range").mean()["ram"]
bars = plt.bar(ram.index  , ram.values  , color = "purple")
plt.xticks(ram.index)
plt.xlabel("Price range")
plt.ylabel("ram size")

"""## ***FEATURE SELECTION AND SCALING***"""

X = mobile.drop(columns=['Price_range'])
y = mobile['Price_range']

k_best_features = SelectKBest(score_func=chi2, k=10)
X_new = k_best_features.fit_transform(X, y)

selected_feature_indices = k_best_features.get_support(indices=True)
selected_feature_names = X.columns[selected_feature_indices]
print("Selected feature names:", selected_feature_names)

mobile_selected_features = mobile.loc[:, selected_feature_names]

# Feature scaling
scaler = MinMaxScaler()
scaled_data = scaler.fit_transform(mobile_selected_features)

scaled_df = pd.DataFrame(scaled_data, columns=mobile_selected_features.columns)

print(scaled_df)

"""## Dataset Splitting"""

X_train , X_test , y_train , y_test = train_test_split(X , y , test_size=0.3, random_state=42)

print(len(X_train))
print(len(X_test))

models = {}
model_names = []
accuracies = []

"""### ***DATASET TRAIN AND TEST***

### Decision Tree
"""

decision_tree = DecisionTreeClassifier()

decision_tree.fit(X_train, y_train)

y_pred = decision_tree.predict(X_test)

accuracy = accuracy_score(y_test, y_pred)
accuracies.append(accuracy)
print("Accuracy:", accuracy)

print("Classification Report:")
print(classification_report(y_test, y_pred))

confusion = confusion_matrix(y_test, y_pred)
cm = confusion
plt.figure(figsize=(6, 4))
sns.heatmap(cm, annot=True, fmt="d", cmap="Blues")
plt.xlabel('Predicted')
plt.ylabel('True')
plt.title(f'Confusion Matrix for Decision Tree')
plt.show()

models["Decision Tree"] =decision_tree
model_names.append('Decision Tree')

"""## **SVM**"""

svm_classifier = SVC(kernel='linear')

svm_classifier.fit(X_train, y_train)

y_pred = svm_classifier.predict(X_test)


accuracy = accuracy_score(y_test, y_pred)
accuracies.append(accuracy)
print("Accuracy:", accuracy)


print("Classification Report:")
print(classification_report(y_test, y_pred))

confusion = confusion_matrix(y_test, y_pred)
cm = confusion
plt.figure(figsize=(6, 4))
sns.heatmap(cm, annot=True, fmt="d", cmap="Blues")
plt.xlabel('Predicted')
plt.ylabel('True')
plt.title(f'Confusion Matrix for SVM classifier')
plt.show()


models["Support Vector Machine"] =svm_classifier
model_names.append('Support Vector Machine')

"""## **KNN**"""

from sklearn.neighbors import KNeighborsClassifier
k = 5
knn_classifier = KNeighborsClassifier(n_neighbors=k)


knn_classifier.fit(X_train, y_train)


y_pred = knn_classifier.predict(X_test)


accuracy = accuracy_score(y_test, y_pred)
accuracies.append(accuracy)
print("Accuracy:", accuracy)


print("Classification Report:")
print(classification_report(y_test, y_pred))

confusion = confusion_matrix(y_test, y_pred)
cm = confusion
plt.figure(figsize=(6, 4))
sns.heatmap(cm, annot=True, fmt="d", cmap="Blues")
plt.xlabel('Predicted')
plt.ylabel('True')
plt.title(f'Confusion Matrix for KNN classifier')
plt.show()


models["K-Nearest Neighbors"] =knn_classifier
model_names.append('KNN')

"""## ***MODEL COMPARISON***"""

import matplotlib.pyplot as plt


colors = ['skyblue', 'salmon', 'lightgreen', 'orange', 'lightcoral', 'deepskyblue']

plt.figure(figsize=(10, 6))
plt.bar(model_names, accuracies, color=colors[:len(model_names)])
plt.title('Prediction Accuracy of Different Models')
plt.xlabel('Models')
plt.ylabel('Accuracy')
plt.ylim(0, 1)
plt.xticks(rotation=45)
plt.show()